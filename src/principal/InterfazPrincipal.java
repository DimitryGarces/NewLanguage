package principal;

import java.io.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Diego
 */
public class InterfazPrincipal extends javax.swing.JFrame {

    Semantico objSem = new Semantico();
    int[] vecSal;
    NumLinecita numlinea;
    Lexico lexInv = new Lexico();
    Renglon[] codigoFuente;
    String[] divisionRenglones;
    String[] tablaIdenFilas;
    ArrayList<String[]> tablaIdenCol = new ArrayList<>();
    ArrayList<String[]> tablaIdenFunMet = new ArrayList<>();
    ArrayList<String[]> tablaIdenParam = new ArrayList<>();
    ArrayList<int[]> rangoFunMet = new ArrayList<>();
    List<String[]> rangosAsig = new ArrayList<>();
    String programaEjecutado = "";
    String opInfija = "";
    ArrayList<String> variablesCAP = new ArrayList<>();

    /**
     * Creates new form InterfazPrincipal
     */
    public InterfazPrincipal() {
        initComponents();
        numlinea = new NumLinecita(jTProgramaFuente);
        jScrollPane1.setRowHeaderView(numlinea);
        pnSintactico.setVisible(false);
        pnSemantico.setVisible(false);
        pnIntermedio.setVisible(false);
        pnOptimizacion.setVisible(false);
        pnObjeto.setVisible(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnContenedor = new javax.swing.JPanel();
        pnCarga1 = new javax.swing.JPanel();
        lbCargar = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        pnGuardar = new javax.swing.JPanel();
        lbGuardar = new javax.swing.JLabel();
        pnSintactico = new javax.swing.JPanel();
        lbSintactico = new javax.swing.JLabel();
        pnSemantico = new javax.swing.JPanel();
        lbSemantico = new javax.swing.JLabel();
        pnOptimizacion = new javax.swing.JPanel();
        lbOptimizacion = new javax.swing.JLabel();
        pnIntermedio = new javax.swing.JPanel();
        lbIntermedio = new javax.swing.JLabel();
        pnLexico = new javax.swing.JPanel();
        lbLexico = new javax.swing.JLabel();
        pnObjeto = new javax.swing.JPanel();
        lbObjeto = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTProgramaFuente = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTProgramaCompilado = new javax.swing.JTextArea();
        lbLex = new javax.swing.JLabel();
        lbSin = new javax.swing.JLabel();
        lbSem = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTProgramaSintactico = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTProgramaSemantico = new javax.swing.JTextArea();
        jScrollPane5 = new javax.swing.JScrollPane();
        erroresLexicos = new javax.swing.JTextArea();
        jScrollPane7 = new javax.swing.JScrollPane();
        jTProgramaCodigoIntermedio = new javax.swing.JTextArea();
        jLabel3 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        pnContenedor.setBackground(new java.awt.Color(204, 204, 204));
        pnContenedor.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        pnCarga1.setBackground(new java.awt.Color(204, 204, 204));

        lbCargar.setBackground(new java.awt.Color(204, 204, 204));
        lbCargar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/jugar.png"))); // NOI18N
        lbCargar.setText("Cargar");
        lbCargar.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        lbCargar.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                lbCargarMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout pnCarga1Layout = new javax.swing.GroupLayout(pnCarga1);
        pnCarga1.setLayout(pnCarga1Layout);
        pnCarga1Layout.setHorizontalGroup(
            pnCarga1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnCarga1Layout.createSequentialGroup()
                .addComponent(lbCargar, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        pnCarga1Layout.setVerticalGroup(
            pnCarga1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnCarga1Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbCargar, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pnContenedor.add(pnCarga1, new org.netbeans.lib.awtextra.AbsoluteConstraints(1200, 70, 80, 30));

        jLabel1.setFont(new java.awt.Font("Consolas", 1, 18)); // NOI18N
        jLabel1.setText("Programa Fuente");
        pnContenedor.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(300, 20, -1, -1));

        jLabel2.setBackground(new java.awt.Color(255, 255, 255));
        jLabel2.setFont(new java.awt.Font("Consolas", 1, 18)); // NOI18N
        jLabel2.setText("Programa Compilado");
        pnContenedor.add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 20, -1, -1));

        pnGuardar.setBackground(new java.awt.Color(204, 204, 204));

        lbGuardar.setBackground(new java.awt.Color(255, 255, 255));
        lbGuardar.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/guardar-el-archivo.png"))); // NOI18N
        lbGuardar.setText("Guardar");
        lbGuardar.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        lbGuardar.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                lbGuardarMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout pnGuardarLayout = new javax.swing.GroupLayout(pnGuardar);
        pnGuardar.setLayout(pnGuardarLayout);
        pnGuardarLayout.setHorizontalGroup(
            pnGuardarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnGuardarLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lbGuardar, javax.swing.GroupLayout.PREFERRED_SIZE, 74, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        pnGuardarLayout.setVerticalGroup(
            pnGuardarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnGuardarLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbGuardar, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pnContenedor.add(pnGuardar, new org.netbeans.lib.awtextra.AbsoluteConstraints(1200, 20, 80, 30));

        pnSintactico.setBackground(new java.awt.Color(255, 255, 255));
        pnSintactico.setMinimumSize(new java.awt.Dimension(83, 28));

        lbSintactico.setBackground(new java.awt.Color(255, 255, 255));
        lbSintactico.setFont(new java.awt.Font("Consolas", 1, 12)); // NOI18N
        lbSintactico.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/sintaxis (1).png"))); // NOI18N
        lbSintactico.setText("Sintactico");
        lbSintactico.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        lbSintactico.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        lbSintactico.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                lbSintacticoMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout pnSintacticoLayout = new javax.swing.GroupLayout(pnSintactico);
        pnSintactico.setLayout(pnSintacticoLayout);
        pnSintacticoLayout.setHorizontalGroup(
            pnSintacticoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(lbSintactico, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        pnSintacticoLayout.setVerticalGroup(
            pnSintacticoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnSintacticoLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbSintactico, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pnContenedor.add(pnSintactico, new org.netbeans.lib.awtextra.AbsoluteConstraints(470, 500, 100, 30));

        pnSemantico.setBackground(new java.awt.Color(255, 255, 255));

        lbSemantico.setBackground(new java.awt.Color(255, 255, 255));
        lbSemantico.setFont(new java.awt.Font("Consolas", 1, 12)); // NOI18N
        lbSemantico.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/semantica.png"))); // NOI18N
        lbSemantico.setText("Semantico");
        lbSemantico.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        lbSemantico.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        lbSemantico.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                lbSemanticoMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout pnSemanticoLayout = new javax.swing.GroupLayout(pnSemantico);
        pnSemantico.setLayout(pnSemanticoLayout);
        pnSemanticoLayout.setHorizontalGroup(
            pnSemanticoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnSemanticoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lbSemantico, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        pnSemanticoLayout.setVerticalGroup(
            pnSemanticoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnSemanticoLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbSemantico, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pnContenedor.add(pnSemantico, new org.netbeans.lib.awtextra.AbsoluteConstraints(790, 500, 110, 30));

        lbOptimizacion.setText("Optimizacion");
        lbOptimizacion.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                lbOptimizacionMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout pnOptimizacionLayout = new javax.swing.GroupLayout(pnOptimizacion);
        pnOptimizacion.setLayout(pnOptimizacionLayout);
        pnOptimizacionLayout.setHorizontalGroup(
            pnOptimizacionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnOptimizacionLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbOptimizacion))
        );
        pnOptimizacionLayout.setVerticalGroup(
            pnOptimizacionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnOptimizacionLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbOptimizacion, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pnContenedor.add(pnOptimizacion, new org.netbeans.lib.awtextra.AbsoluteConstraints(1220, 190, 70, 30));

        lbIntermedio.setText("Intermedio");
        lbIntermedio.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                lbIntermedioMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout pnIntermedioLayout = new javax.swing.GroupLayout(pnIntermedio);
        pnIntermedio.setLayout(pnIntermedioLayout);
        pnIntermedioLayout.setHorizontalGroup(
            pnIntermedioLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnIntermedioLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(lbIntermedio)
                .addContainerGap())
        );
        pnIntermedioLayout.setVerticalGroup(
            pnIntermedioLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnIntermedioLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbIntermedio, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pnContenedor.add(pnIntermedio, new org.netbeans.lib.awtextra.AbsoluteConstraints(1110, 500, 70, 30));

        pnLexico.setBackground(new java.awt.Color(255, 255, 255));
        pnLexico.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        lbLexico.setBackground(new java.awt.Color(255, 255, 255));
        lbLexico.setFont(new java.awt.Font("Consolas", 1, 12)); // NOI18N
        lbLexico.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/eleccion-de-idioma.png"))); // NOI18N
        lbLexico.setText("Lexico");
        lbLexico.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        lbLexico.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                lbLexicoMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout pnLexicoLayout = new javax.swing.GroupLayout(pnLexico);
        pnLexico.setLayout(pnLexicoLayout);
        pnLexicoLayout.setHorizontalGroup(
            pnLexicoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnLexicoLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbLexico, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        pnLexicoLayout.setVerticalGroup(
            pnLexicoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnLexicoLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbLexico, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pnContenedor.add(pnLexico, new org.netbeans.lib.awtextra.AbsoluteConstraints(150, 500, -1, 30));

        lbObjeto.setText("Objeto");

        javax.swing.GroupLayout pnObjetoLayout = new javax.swing.GroupLayout(pnObjeto);
        pnObjeto.setLayout(pnObjetoLayout);
        pnObjetoLayout.setHorizontalGroup(
            pnObjetoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnObjetoLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbObjeto, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        pnObjetoLayout.setVerticalGroup(
            pnObjetoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnObjetoLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(lbObjeto, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pnContenedor.add(pnObjeto, new org.netbeans.lib.awtextra.AbsoluteConstraints(1210, 130, 70, 30));

        jScrollPane1.setBackground(new java.awt.Color(51, 51, 51));

        jTProgramaFuente.setBackground(new java.awt.Color(102, 102, 102));
        jTProgramaFuente.setColumns(20);
        jTProgramaFuente.setForeground(new java.awt.Color(204, 255, 255));
        jTProgramaFuente.setRows(5);
        jTProgramaFuente.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTProgramaFuenteKeyTyped(evt);
            }
        });
        jScrollPane1.setViewportView(jTProgramaFuente);

        pnContenedor.add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(300, 40, 450, 230));

        jTProgramaCompilado.setEditable(false);
        jTProgramaCompilado.setBackground(new java.awt.Color(102, 102, 102));
        jTProgramaCompilado.setColumns(20);
        jTProgramaCompilado.setForeground(new java.awt.Color(204, 255, 255));
        jTProgramaCompilado.setRows(5);
        jScrollPane2.setViewportView(jTProgramaCompilado);

        pnContenedor.add(jScrollPane2, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 40, 260, 220));

        lbLex.setFont(new java.awt.Font("Consolas", 1, 14)); // NOI18N
        lbLex.setText("Lexico:");
        pnContenedor.add(lbLex, new org.netbeans.lib.awtextra.AbsoluteConstraints(240, 280, -1, -1));

        lbSin.setFont(new java.awt.Font("Consolas", 1, 14)); // NOI18N
        lbSin.setText("Sintactico:");
        pnContenedor.add(lbSin, new org.netbeans.lib.awtextra.AbsoluteConstraints(450, 280, -1, -1));

        lbSem.setBackground(new java.awt.Color(255, 255, 255));
        lbSem.setFont(new java.awt.Font("Consolas", 1, 14)); // NOI18N
        lbSem.setText("Semantico:");
        pnContenedor.add(lbSem, new org.netbeans.lib.awtextra.AbsoluteConstraints(640, 280, -1, -1));

        jTProgramaSintactico.setEditable(false);
        jTProgramaSintactico.setBackground(new java.awt.Color(102, 102, 102));
        jTProgramaSintactico.setColumns(20);
        jTProgramaSintactico.setForeground(new java.awt.Color(204, 255, 255));
        jTProgramaSintactico.setRows(5);
        jScrollPane3.setViewportView(jTProgramaSintactico);

        pnContenedor.add(jScrollPane3, new org.netbeans.lib.awtextra.AbsoluteConstraints(370, 320, 310, 160));

        jTProgramaSemantico.setEditable(false);
        jTProgramaSemantico.setBackground(new java.awt.Color(102, 102, 102));
        jTProgramaSemantico.setColumns(20);
        jTProgramaSemantico.setForeground(new java.awt.Color(204, 255, 255));
        jTProgramaSemantico.setRows(5);
        jScrollPane4.setViewportView(jTProgramaSemantico);

        pnContenedor.add(jScrollPane4, new org.netbeans.lib.awtextra.AbsoluteConstraints(730, 320, 260, 160));

        erroresLexicos.setEditable(false);
        erroresLexicos.setBackground(new java.awt.Color(102, 102, 102));
        erroresLexicos.setColumns(20);
        erroresLexicos.setForeground(new java.awt.Color(204, 255, 255));
        erroresLexicos.setRows(5);
        jScrollPane5.setViewportView(erroresLexicos);

        pnContenedor.add(jScrollPane5, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 320, 300, 160));

        jTProgramaCodigoIntermedio.setEditable(false);
        jTProgramaCodigoIntermedio.setBackground(new java.awt.Color(102, 102, 102));
        jTProgramaCodigoIntermedio.setColumns(20);
        jTProgramaCodigoIntermedio.setForeground(new java.awt.Color(204, 255, 255));
        jTProgramaCodigoIntermedio.setRows(5);
        jScrollPane7.setViewportView(jTProgramaCodigoIntermedio);

        pnContenedor.add(jScrollPane7, new org.netbeans.lib.awtextra.AbsoluteConstraints(770, 40, 410, 230));

        jLabel3.setFont(new java.awt.Font("Consolas", 1, 18)); // NOI18N
        jLabel3.setText("Codigo intermedio");
        pnContenedor.add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(770, 20, -1, 20));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(34, 34, 34)
                .addComponent(pnContenedor, javax.swing.GroupLayout.DEFAULT_SIZE, 1303, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(16, 16, 16)
                .addComponent(pnContenedor, javax.swing.GroupLayout.DEFAULT_SIZE, 551, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void lbLexicoMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_lbLexicoMouseClicked

        pnSintactico.setVisible(false);
        pnSemantico.setVisible(false);
        lbSin.setText("Sintactico:");
        lbSem.setText("Semantico:");
        jTProgramaSintactico.setText("");
        jTProgramaSemantico.setText("");
        erroresLexicos.setText("");
        programaEjecutado = jTProgramaFuente.getText();
        String[] divisionRenglones = programaEjecutado.split("(?<=\\n)");
        String resultadoLexico = "";
        boolean b = true;
        codigoFuente = new Renglon[divisionRenglones.length + 1];
        Renglon renglon;
        for (int i = 0; i < divisionRenglones.length; i++) {
            StringTokenizer st = new StringTokenizer(divisionRenglones[i], "+-^*/()%#;=<>{}&| \n\b\r\t\",:'", true);
            String texto = "";
            String cadena;
            while (st.hasMoreElements()) {
                cadena = st.nextToken();
                if (cadena.equals("=")) {
                    texto = texto + cadena;
                    if (st.hasMoreElements()) {
                        cadena = st.nextToken();
                        if (cadena.equals("=")) {
                            texto = texto + cadena + "\n";
                        } else if (!(cadena.equals(" ") || cadena.equals("\t"))) {
                            texto = texto + "\n" + cadena + "\n";
                        } else {
                            texto = texto + "\n";
                        }
                    }
                } else {
                    if (cadena.equals("<") || cadena.equals(">") || cadena.equals("!")) {
                        texto = texto + cadena;
                        if (st.hasMoreElements()) {
                            cadena = st.nextToken();
                            if (cadena.equals("=")) {
                                texto = texto + cadena + "\n";
                            } else if (!(cadena.equals(" ") || cadena.equals("\t"))) {
                                texto = texto + "\n" + cadena + "\n";

                            } else {
                                texto = texto + "\n";
                            }
                        }
                    } else {
                        if (cadena.equals("&")) {
                            texto = texto + cadena;
                            if (st.hasMoreElements()) {
                                cadena = st.nextToken();
                                if (cadena.equals("&")) {
                                    texto = texto + cadena + "\n";
                                } else {
                                    texto = texto + "\n" + cadena + "\n";
                                }
                            }
                        } else if (cadena.equals("|")) {
                            texto = texto + cadena;
                            if (st.hasMoreElements()) {
                                cadena = st.nextToken();
                                if (cadena.equals("|")) {
                                    texto = texto + cadena + "\n";
                                } else {
                                    texto = texto + "\n" + cadena + "\n";
                                }
                            }
                        } else if (cadena.equals("\"")) {
                            texto = texto + cadena;
                            while (st.hasMoreElements()) {
                                cadena = st.nextToken();
                                if (cadena.equals("\"") || cadena.equals("\r") || cadena.equals("\n")) {
                                    break;
                                }
                                if (cadena.equals(" ") || cadena.equals("\t")) {
                                    cadena = " ";
                                }
                                texto = texto + cadena;
                            }
                            texto = texto + cadena + "\n";
                        } else if (cadena.equals(" ") || cadena.equals("\t")) {
                            cadena = "";
                        } else if (cadena.equals("'")) {
                            texto = texto + cadena;
                            while (st.hasMoreElements()) {
                                cadena = st.nextToken();
                                if (cadena.equals("'")) {
                                    texto = texto + cadena + "\n";
                                    break;
                                }
                                texto = texto + cadena;
                            }
                        } else {
                            texto = texto + cadena + "\n";
                        }
                    }
                }
            }
            StringTokenizer st2 = new StringTokenizer(texto, "\n\t\r");
            Lexico objLex2 = new Lexico();
            vecSal = new int[st2.countTokens()];
            int j = 0;
            while (st2.hasMoreElements()) {
                objLex2 = objLex2.Etiquetar(st2.nextToken());
                resultadoLexico = resultadoLexico + objLex2.lexema + "\t" + objLex2.nombre + "\n";
                vecSal[j] = objLex2.numero;
                switch (vecSal[j]) {
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 105:
                        b = false;
                        erroresLexicos.setText(erroresLexicos.getText() + "\n" + objLex2.nombre + " en linea: " + (i + 1));
                        break;
                }
                j++;

            }
            renglon = new Renglon(vecSal);
            codigoFuente[i] = renglon;

        }
//            vecSal[vecSal.length - 1] = 53;
        if (b) {
            lbLex.setText("Lexicamente: Correcto.");
            pnSintactico.setVisible(true);
        } else {
            lbLex.setText("Lexicamente: Incorrecto.");
            pnSintactico.setVisible(false);
        }
        jTProgramaCompilado.setText(resultadoLexico);
//        jTProgramaCompilado.setText(texto);
    }//GEN-LAST:event_lbLexicoMouseClicked

    private void lbSintacticoMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_lbSintacticoMouseClicked
        pnSemantico.setVisible(false);
        pnIntermedio.setVisible(false);
        pnOptimizacion.setVisible(false);
        pnObjeto.setVisible(false);
        jTProgramaSintactico.setText("");
        jTProgramaSemantico.setText("");
        String cadena = "";
        int[] pp
                = {
                    45
                };
        Renglon p = new Renglon(pp);
        codigoFuente[codigoFuente.length - 1] = p;
        int mg[][] = {{},
        {23, 188, 152, 151, 22, 51, 12},
        {151, 31, 51, 13},
        {},
        {152, 153},
        {},
        {156},
        {192},
        {185},
        {182},
        {154, 155},
        {},
        {156},
        {170},
        {168},
        {159},
        {171},
        {173},
        {174},
        {177},
        {31, 193, 52},
        {31, 52, 24},
        {158, 35},
        {166},
        {17},
        {18},
        {160, 23, 154, 22, 21, 161, 20, 3},
        {23, 154, 22, 4},
        {},
        {162, 166, 27, 166},
        {161, 26},
        {},
        {50},
        {51},
        {164},
        {53},
        {54},
        {165, 52},
        {189},
        {},
        {167, 163},
        {167, 163, 25},
        {},
        {31, 21, 169, 166, 20, 1},
        {169, 166, 34},
        {},
        {31, 21, 52, 20, 2},
        {23, 154, 22, 21, 172, 50, 30, 50, 20, 5},
        {50, 29},
        {},
        {23, 154, 22, 21, 161, 20, 6},
        {31, 21, 161, 20, 6, 23, 154, 22, 7},
        {31, 11, 154, 30, 176, 8},
        {53},
        {51},
        {50},
        {23, 178, 22, 21, 52, 20, 9},
        {178, 175},
        {179},
        {154, 30, 10},
        {},
        {52, 24},
        {180, 16},
        {23, 31, 52, 19, 154, 22, 21, 183, 20, 181},
        {184, 180},
        {183, 29},
        {},
        {23, 154, 22, 21, 186, 20, 51, 15},
        {187, 180},
        {186, 29},
        {},
        {23, 154, 22, 14},
        {21, 190, 20},
        {191, 52},
        {191, 52, 29},
        {},
        {31, 157, 52},
        {189},
        {157}
        };

        int mt[][] = new int[45][55];
        for (int i = 0; i < 45; i++) {
            for (int j = 0; j < 55; j++) {
                mt[i][j] = -1;
            }
        }
        mt[0][12] = 1;
        mt[1][13] = 2;
        mt[1][14] = 3;
        mt[1][15] = 3;
        mt[1][16] = 3;
        mt[1][24] = 3;
        mt[1][52] = 3;
        mt[2][14] = 5;
        mt[2][15] = 4;
        mt[2][16] = 4;
        mt[2][24] = 4;
        mt[2][52] = 4;
        mt[3][15] = 8;
        mt[3][16] = 9;
        mt[3][24] = 6;
        mt[3][31] = 7;
        mt[3][52] = 7;
        mt[4][1] = 10;
        mt[4][2] = 10;
        mt[4][3] = 10;
        mt[4][5] = 10;
        mt[4][6] = 10;
        mt[4][7] = 10;
        mt[4][9] = 10;
        mt[4][11] = 11;
        mt[4][19] = 11;
        mt[4][23] = 11;
        mt[4][24] = 10;
        mt[4][52] = 10;
        mt[5][1] = 14;
        mt[5][2] = 13;
        mt[5][3] = 15;
        mt[5][5] = 16;
        mt[5][6] = 17;
        mt[5][7] = 18;
        mt[5][9] = 19;
//        mt[5][31] = 20;
        mt[5][24] = 12;
//        mt[5][34] = 10;
        mt[5][52] = 20;
        mt[6][24] = 21;
        mt[7][35] = 22;
        mt[8][17] = 24;
        mt[8][18] = 25;

        mt[8][50] = 23;
        mt[8][51] = 23;
        mt[8][52] = 23;
        mt[8][53] = 23;
        mt[8][54] = 23;

        mt[9][3] = 26;
        mt[10][1] = 28;
        mt[10][2] = 28;
        mt[10][3] = 28;
        mt[10][4] = 27;
        mt[10][5] = 28;
        mt[10][6] = 28;
        mt[10][7] = 28;
        mt[10][9] = 28;
        mt[10][11] = 28;
        mt[10][19] = 28;
        mt[10][23] = 28;
        mt[10][24] = 28;
        mt[10][52] = 28;

        mt[11][50] = 29;
        mt[11][51] = 29;
        mt[11][52] = 29;
        mt[11][53] = 29;
        mt[11][54] = 29;
//        mt[11][21] = 29;
//        mt[11][25] = 29;
        mt[11][27] = 29;
//        mt[11][31] = 29;
//        mt[11][34] = 29;
        mt[12][21] = 31;
        mt[12][26] = 30;

        mt[13][50] = 32;
        mt[13][51] = 33;
        mt[13][52] = 34;
        mt[13][53] = 35;
        mt[13][54] = 36;

        mt[14][52] = 37;

        mt[15][20] = 38;
        mt[15][21] = 39;
        mt[15][25] = 39;
        mt[15][26] = 39;
        mt[15][27] = 39;
        mt[15][31] = 39;
        mt[15][34] = 39;

        mt[16][50] = 40;
        mt[16][51] = 40;
        mt[16][52] = 40;
        mt[16][53] = 40;
        mt[16][54] = 40;

        mt[17][21] = 42;
        mt[17][25] = 41;
        mt[17][26] = 42;
        mt[17][27] = 42;
        mt[17][31] = 42;
        mt[17][34] = 42;

        mt[18][1] = 43;

        mt[19][21] = 45;
        mt[19][34] = 44;

        mt[20][2] = 46;

        mt[21][5] = 47;

        mt[22][21] = 49;
        mt[22][29] = 48;

        mt[23][6] = 50;

        mt[24][7] = 51;

        mt[25][8] = 52;

        mt[26][53] = 53;
        mt[26][51] = 54;
        mt[26][50] = 55;

        mt[27][9] = 56;

        mt[28][8] = 57;
        mt[28][10] = 58;
        mt[28][23] = 58;

        mt[29][10] = 59;
        mt[29][23] = 60;

        mt[30][24] = 61;

        mt[31][16] = 62;

        mt[32][16] = 63;

        mt[33][24] = 64;

        mt[34][29] = 65;
        mt[34][21] = 66;

        mt[35][15] = 67;

        mt[36][24] = 68;

        mt[37][29] = 69;
        mt[37][21] = 70;

        mt[38][14] = 71;

        mt[39][20] = 72;

        mt[40][52] = 73;

        mt[41][29] = 74;
        mt[41][21] = 75;

        mt[42][52] = 76;

        mt[43][20] = 77;
        mt[43][35] = 78;

        int vecMov[]
                = {
                    45, 150
                };
        int vecMovAux[];
        int pr;
        int pc;
        int nl;
        int tv;
        Lexico le = new Lexico();
        boolean banderaErrores = true;
        int[] palabras;

//        int[] pa;
//        for (int i = 0; i < codigoFuente.length; i++) {
//            pa = codigoFuente[i].getPalabras();
//            for (int j = 0; j < pa.length; j++) {
//                System.out.println("Linea "+i+" co"+pa[j]);
//            }
//        }
        boolean error = false;
        for (int h = 0; h < codigoFuente.length; h++) {
            palabras = codigoFuente[h].getPalabras();
            int i = 0;
            do {
                if (palabras.length == 0) {
                    break;
                }
                pr = vecMov[vecMov.length - 1];
                if (pr >= 150) {
                    pr = pr - 150;
                    pc = palabras[i];
                    nl = mt[pr][pc];
                    if (nl != -1) {
                        vecMovAux = vecMov;
                        vecMov = new int[(vecMovAux.length + mg[nl].length) - 1];
                        tv = 0;
                        for (int j = 0; j < vecMovAux.length - 1; j++) {
                            vecMov[j] = vecMovAux[j];
                        }
                        for (int j = vecMovAux.length - 1; j < vecMov.length; j++) {
                            vecMov[j] = mg[nl][tv];
                            tv++;
                        }
                    } else {
                        lbSin.setText("Sintactico: Incorrecto.");
                        banderaErrores = false;
                        error = true;
                        String b = le.EtiquetarInvertido(palabras[i], false);

                        jTProgramaSintactico.setText(jTProgramaSintactico.getText()
                                + "Error sintactico en linea " + (h + 1) + " al recibir " + b + "\n");
                        int contador = 0;

                        i++;
                        vecMovAux = vecMov;
                        vecMov = new int[vecMovAux.length - contador];
                        for (int j = 0; j < vecMov.length; j++) {
                            vecMov[j] = vecMovAux[j];
                        }
                        break;
                    }
                } else {
                    if (palabras[i] == vecMov[vecMov.length - 1]) {
                        i++;
                        vecMovAux = vecMov;
                        vecMov = new int[vecMovAux.length - 1];
                        for (int j = 0; j < vecMov.length; j++) {
                            vecMov[j] = vecMovAux[j];
                        }
                    } else {
                        lbSin.setText("Sintactico: Incorrecto.");
                        banderaErrores = false;
                        error = true;
                        String b = le.EtiquetarInvertido(palabras[i], false);

                        jTProgramaSintactico.setText(jTProgramaSintactico.getText()
                                + "Error sintactico en linea " + (h + 1) + " con: " + b + "\n");
                        i++;
                        int contador = 0;
                        vecMovAux = vecMov;
                        vecMov = new int[vecMovAux.length - contador];
                        for (int j = 0; j < vecMov.length; j++) {
                            vecMov[j] = vecMovAux[j];
                        }
                        break;
                    }
                }
            } while (i < palabras.length);
            if (error) {
                banderaErrores = false;
                break;
            }
        }
        if (vecMov.length == 0 && banderaErrores == true) {
            lbSin.setText("Sintactico: Correcto.");
            pnSemantico.setVisible(true);
        }
    }//GEN-LAST:event_lbSintacticoMouseClicked

    private void lbSemanticoMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_lbSemanticoMouseClicked
//        pnIntermedio.setVisible(true);
        variablesCAP = new ArrayList<String>();

        System.out.println("Arreglo Vacio " + variablesCAP);

        variablesCAP = recopilarVarCap(jTProgramaFuente.getText()); //Recopila variables que estan dentro de un CAP

        System.out.println("Arreglo con variables CAP " + variablesCAP);

        opInfija = "";
        jTProgramaCodigoIntermedio.setText("");
        pnOptimizacion.setVisible(true);
        String text = programaEjecutado;
        objSem.setModeloTabla();
        //Guarda las variables de tipo CAD
        ArrayList<String> variables = objSem.obtNomVar(programaEjecutado);

        //Elimina el nombre de las funciones en donde se guardo las variables de tipo CAD
        variables = objSem.elimNomFunCad(programaEjecutado, variables);

        //Verificaci√≥n de la entrada de datos
        String errorCAP = objSem.verificaCAP(programaEjecutado, variables);
        if (!errorCAP.equals("")) {
            jTProgramaSemantico.setText(jTProgramaSemantico.getText() + errorCAP);
        }

        int rang[];
        //Dividimos nuestro programa de acuerdo a los renglones
        divisionRenglones = programaEjecutado.split("(?<=\\n)");
        StringTokenizer palabras, palabrasOper, palabrasAux;

        tablaIdenCol = new ArrayList<>();
        tablaIdenFunMet = new ArrayList<>();
        tablaIdenParam = new ArrayList<>();
        rangosAsig = new ArrayList<>();
        rangoFunMet = new ArrayList<>();
        String palabra = "", texto = "", mensaje = "";
        boolean palRep, varDec, banderaErrores = true, banderaVE = false;
        int palabrasAsig[];
        String rango[];

        //Iniciamos un recorrido para ver el rango de variables utilizadas en funciones y ademas declararlas
        for (int i = 0; i < divisionRenglones.length; i++) {
            palabras = new StringTokenizer(divisionRenglones[i], " =;(),");
            palabra = palabras.nextToken().replaceAll("\n", "");
            //Cada que hallemos una declaracion de funcion/metodo haremos sus operaciones necesarias atravez de funAmet
            if (palabra.equals("FUN") || palabra.equals("MET")) {
                banderaErrores = funAmet(palabra, palabras, i, texto);
            }
        }

        for (int i = 0; i < rangosAsig.size(); i++) {
            System.out.println("Llamada: " + rangosAsig.get(i)[0] + " de linea: " + rangosAsig.get(i)[1] + " a " + rangosAsig.get(i)[2]);
        }
        //Fin de la primera fase e inicio de la segunda

        //Iniciamos el recorrido de los renglones
        for (int i = 0; i < divisionRenglones.length; i++) {
            //Separamos las palabras en un arreglo, de un renglon determinado por el ciclo 
            palabras = new StringTokenizer(divisionRenglones[i], " =;(),");
            palabrasAux = new StringTokenizer(divisionRenglones[i], " =;(),");

            texto = "";
            while (palabrasAux.hasMoreElements()) {
                texto = texto + palabrasAux.nextToken();
            }
            //Guardamos tambien en otro arreglo los operadores sin contar los espacios en blanco
            palabrasOper = new StringTokenizer(texto, "=+-*/", true);
            palabra = palabras.nextToken().replaceAll("\n", "");
            if (palabra.equals("NUM") || palabra.equals("CAD")
                    || palabra.equals("CHAR") || palabra.equals("BOOL")) {
                //Encuentra declaracion de dato, almacenamos a que tipo se refiere
                String tipo = palabra;
                palRep = false;
                tablaIdenFilas = new String[5];
                //Agregamos en que linea de codigo fue hallado, ademas a que tipo de dato se refiere
                tablaIdenFilas[0] = String.valueOf(i + 1);
                tablaIdenFilas[1] = objSem.conversionNum(palabra);
                tablaIdenFilas[2] = palabras.nextToken();
                tablaIdenFilas[3] = "Null";
                tablaIdenFilas[4] = "FALS";
                //Validamos que existan o no funciones/metodos
                if (!rangosAsig.isEmpty()) {
                    String l = " ";
                    for (int j = 0; j < rangosAsig.size(); j++) {
                        /*Si al recorrer los rangos agregados comprobamos que 
                        la delcaracion esta entre el rango de alguna funcion entonces llamaremos a sus parametros*/
                        if (i >= Integer.parseInt(rangosAsig.get(j)[1])
                                && i <= Integer.parseInt(rangosAsig.get(j)[2])) {
                            l = rangosAsig.get(j)[0];
                            break;
                        }
                    }
                    /*Una vez que haya encontrado el nombre del metodo podra ir comparando ahora el nombre de las 
                    variables que tengan esos parametros y determinar si ya a sido declarada antes*/
                    if (!l.equals(" ")) {
                        for (int j = 0; j < tablaIdenParam.size(); j++) {
                            if (tablaIdenParam.get(j)[0].equals(l)) {
                                if (tablaIdenFilas[2].equals(tablaIdenParam.get(j)[2])) {
                                    lbSem.setText("Semantico: Incorrecto");
                                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Variable en parametro de funcion "
                                            + tablaIdenParam.get(j)[0] + " en la linea " + tablaIdenFilas[0] + "\n");
                                    palRep = true;
                                    banderaErrores = false;
                                }
                            }
                        }
                    }
                }
                //Validamos que no haya variables agregadas previamente a nuestro array
                if (!tablaIdenCol.isEmpty() && !tablaIdenFilas.equals("=") && !palRep) {
                    //Si a habido variables declaradas entonces ahora se pregunta si ya esta esa misma variable
                    for (int j = 0; j < tablaIdenCol.size(); j++) {
                        if (tablaIdenCol.get(j)[2].equals(tablaIdenFilas[2])) {
                            lbSem.setText("Semantico: Incorrecto");
                            jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Variable repetida "
                                    + tablaIdenFilas[2] + " en la linea " + tablaIdenFilas[0] + "\n");
                            palRep = true;
                            banderaErrores = false;
                        }
                    }
                }
                if (!palRep) {
                    //Si la palabra no estaba repetida en declaracion, ahora se guardara para validar mas tarde su duplicidad
                    tablaIdenCol.add(tablaIdenFilas);
                }
            } /*Validamos si lo que se esta declarando es una funcion o un metodo para obtener parametros
            Si no se esta declarando verificaremos si se realiza alguna accion con la variable*/ else {
                int pos = -1;

                varDec = false;
                int y = 0;
                banderaVE = false;
                //Obtenemos las palabras de ese renglon
                palabrasAsig = codigoFuente[i].getPalabras();
                for (int j = 0; j < palabrasAsig.length; j++) {
                    switch (palabrasAsig[j]) {
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                            pos = j;
                            break;

                    }
                    if (pos != -1) {
                        break;
                    }
                }

                if (pos != -1) {
                    //Verificamos que se trate de una asignacion
                    if (palabrasAsig[0] == 52 && palabrasAsig[1] == 35) {
                        //Verificamos que la variable haya sido declarada
                        if (!rangosAsig.isEmpty()) {
                            String l = " ";
                            for (int j = 0; j < rangosAsig.size(); j++) {
                                /*Si al recorrer los rangos agregados comprobamos que 
                                la delcaracion esta entre el rango de alguna funcion entonces llamaremos a sus parametros*/
                                if (i >= Integer.parseInt(rangosAsig.get(j)[1])
                                        && i <= Integer.parseInt(rangosAsig.get(j)[2])) {
                                    l = rangosAsig.get(j)[0];
                                    break;
                                }
                            }
                            /*Una vez que haya encontrado el nombre del metodo podra ir comparando ahora el nombre de las 
                            variables que tengan esos parametros y determinar si ya a sido declarada antes*/
                            if (!l.equals(" ")) {
                                for (int j = 0; j < tablaIdenParam.size(); j++) {
                                    if (tablaIdenParam.get(j)[0].equals(l)) {
                                        if (palabra.equals(tablaIdenParam.get(j)[2])) {
                                            banderaVE = true;
                                            //Variable declarada continua procedimiento
                                        }
                                    }
                                }
                            }
                        }
                        /*Como se trata de asignacion verificaremos que la palabra anteriormente guardada
                    este declarada en nuestra lista de variables
                         */
                        if (!banderaVE) {
                            for (int j = 0; j < tablaIdenCol.size(); j++) {
                                if (tablaIdenCol.get(j)[2].equals(palabra)) {
                                    banderaVE = true;
                                    y = j;
                                    break;
                                }
                            }
                        }
                        /*Si la variable fue declarada, por el momento es correcto y 
                    se validaran sus operaciones correspondientes a la*/
                        if (banderaVE) {
//                        lbSem.setText("Semantico: Correcto");
//Funcional
                            banderaErrores = validarOperaciones(y, palabras, palabrasAux, palabrasOper, palabra, banderaVE, i, banderaErrores);
                        } else {
                            lbSem.setText("Semantico: Incorrecto");
                            jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Variable no declarada "
                                    + palabra + " en la linea " + (i + 1) + "\n");
                            banderaErrores = false;
                        }
                    }//Verificamos ademas los ciclos o condicionales que ocupen variables 
                    else if (palabrasAsig[pos] == 52 && palabrasAsig[pos + 1] == 27
                            && (palabrasAsig[pos + 2] >= 50 && palabrasAsig[pos + 2] <= 53)) {
                        for (int j = 0; j < pos - 1; j++) {
                            palabra = palabras.nextToken();
                        }
                        //Verificamos que la variable haya sido declarada
                        if (!rangosAsig.isEmpty()) {
                            String l = " ";
                            for (int j = 0; j < rangosAsig.size(); j++) {
                                /*Si al recorrer los rangos agregados comprobamos que 
                                la delcaracion esta entre el rango de alguna funcion entonces llamaremos a sus parametros*/
                                if (i >= Integer.parseInt(rangosAsig.get(j)[1])
                                        && i <= Integer.parseInt(rangosAsig.get(j)[2])) {
                                    l = rangosAsig.get(j)[0];
                                    break;
                                }
                            }
                            /*Una vez que haya encontrado el nombre del metodo podra ir comparando ahora el nombre de las 
                            variables que tengan esos parametros y determinar si ya a sido declarada antes*/
                            if (!l.equals(" ")) {
                                for (int j = 0; j < tablaIdenParam.size(); j++) {
                                    if (tablaIdenParam.get(j)[0].equals(l)) {
                                        if (palabra.equals(tablaIdenParam.get(j)[2])) {
                                            banderaVE = true;
                                            //Variable declarada continua procedimiento
                                        }
                                    }
                                }
                            }
                        }
                        /*Como se trata de asignacion verificaremos que la palabra anteriormente guardada
                    este declarada en nuestra lista de variables
                         */
                        if (!banderaVE) {
                            for (int j = 0; j < tablaIdenCol.size(); j++) {
                                if (tablaIdenCol.get(j)[2].equals(palabra)) {
                                    banderaVE = true;
                                    y = j;
                                    break;
                                }
                            }
                        }
                        /*Si la variable fue declarada, por el momento es correcto y 
                    se validaran sus operaciones correspondientes a la*/
                        if (banderaVE) {
//                        lbSem.setText("Semantico: Correcto");
//Fases de prueba
                            banderaErrores = validarOperaciones(y, palabras, palabrasAux, palabrasOper, palabra, banderaVE, i, banderaErrores);
                        } else {
                            lbSem.setText("Semantico: Incorrecto");
                            jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Variable no declarada "
                                    + palabra + " en la linea " + (i + 1) + "\n");
                            banderaErrores = false;
                        }
                    }
                }
            }
        }
        if (banderaErrores) {
            lbSem.setText("Sem√°nticamente Correcto");

        } else {
            lbSem.setText("Sem√°nticamente Incorrecto");
            pnOptimizacion.setVisible(false);
        }
        //Guardar nombre de las variables de cada tipo de dato
        ArrayList<String> numerosVar = objSem.obtNomVar(programaEjecutado, "NUM");
        ArrayList<String> boolsVar = objSem.obtNomVar(programaEjecutado, "BOOL");
        ArrayList<String> carsVar = objSem.obtNomVar(programaEjecutado, "CHAR");
        ArrayList<String> cadenasVar = objSem.obtNomVar(programaEjecutado, "CAD");

        //Eliminar nombre de funciones en ArrayList de cada tipo de dato
        numerosVar = objSem.elimNomFunCad(programaEjecutado, numerosVar);
        boolsVar = objSem.elimNomFunCad(programaEjecutado, boolsVar);
        carsVar = objSem.elimNomFunCad(programaEjecutado, carsVar);
        cadenasVar = objSem.elimNomFunCad(programaEjecutado, cadenasVar);

        //Se obtiene el error si es que existe y se manda a la caja de texto
        String errorIMP = objSem.verificaIMP(programaEjecutado, numerosVar, boolsVar, carsVar, cadenasVar, tablaIdenCol);
        if (!errorIMP.equals("")) {
            jTProgramaSemantico.setText(jTProgramaSemantico.getText() + errorIMP);
        }

        // Esta parte siguiente es para eliminar los CAP
        String textoNuevo = eliminaCAP(jTProgramaFuente.getText(), variablesCAP);

        System.out.println("Variables que se eliminan de CAP= " + variablesCAP);

    }//GEN-LAST:event_lbSemanticoMouseClicked

    public boolean funAmet(String tipo, StringTokenizer palabras, int i, String texto) {
        /*Si encontramos la declaracion de una funcion/metodo entonces capturamos el renglon y el nombre de la funcion
                y empezamos a buscar las llaves que determinan cuando inicia y cuando termina esa funcion
                Creamos un arraylist para almacenar las palabras de ese renglon*/
        List<String> funcAmet = new ArrayList<>();
        String nom = "";
        boolean palRep = false, banderaErrores = true;
        String rango[];
        List<String> met = new ArrayList<>();

        //Agregamos en que linea de codigo fue hallado nuestra funcion/metodo
        tablaIdenFilas = new String[5];
        tablaIdenFilas[0] = String.valueOf(i + 1);
        if (tipo.equals("FUN")) {
            while (palabras.hasMoreElements()) {
                funcAmet.add(palabras.nextToken());
            }
            //Salvamos el nombre de la funcion
            nom = funcAmet.get(1);
            tablaIdenFilas[1] = objSem.conversionNum(funcAmet.get(0));
            tablaIdenFilas[2] = funcAmet.get(1);
        } else {
            while (palabras.hasMoreElements()) {
                met.add(palabras.nextToken());
            }
            //Salvamos el nombre del metodo eliminando los " ya que es una cadena
            nom = met.get(0).replaceAll("\"", "");
            tablaIdenFilas[1] = objSem.conversionNum("MET");
            tablaIdenFilas[2] = nom;
        }
        tablaIdenFilas[3] = tipo;
        tablaIdenFilas[4] = "FALS";

        //Validamos que no haya variables agregadas previamente a nuestro array
        if (!tablaIdenFunMet.isEmpty()) {
            //Si a habido variables declaradas entonces ahora se pregunta si ya esta esa misma variable
            for (int j = 0; j < tablaIdenFunMet.size(); j++) {
                if (tablaIdenFunMet.get(j)[2].equals(tablaIdenFilas[2])) {
                    lbSem.setText("Semantico: Incorrecto");
                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Expresion de llamada repetida "
                            + tablaIdenFilas[2] + " en la linea " + tablaIdenFilas[0] + "\n");
                    palRep = true;
                    banderaErrores = false;
                }
            }
        }
        if (!tablaIdenCol.isEmpty() && banderaErrores) {
            //Si a habido variables declaradas entonces ahora se pregunta si ya esta esa misma variable
            for (int j = 0; j < tablaIdenCol.size(); j++) {
                if (tablaIdenCol.get(j)[2].equals(tablaIdenFilas[2])) {
                    lbSem.setText("Semantico: Incorrecto");
                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Expresion de llamada usada en variable "
                            + tablaIdenFilas[2] + " en la linea " + tablaIdenFilas[0] + "\n");
                    palRep = true;
                    banderaErrores = false;
                }
            }
        }
        if (!palRep) {
            //Si la palabra no estaba repetida en fun/met, ahora se guardara para validar mas tarde su duplicidad
            tablaIdenFunMet.add(tablaIdenFilas);
            tablaIdenCol.add(tablaIdenFilas);
        }
        //Una vez que la funcion a sido guardada toca agregar los parametros de dicha funcion/metodo
        tablaIdenFilas = new String[5];
        tablaIdenFilas[3] = String.valueOf(i + 1);
        tablaIdenFilas[4] = "FALS";
        if (tipo.equals("FUN")) {
            for (int j = 2; j < funcAmet.size(); j++) {
                //Cada dos datos es un parametro ya que se compone de TipoDato nombre
                if (j % 2 == 0) {
                    tablaIdenFilas[0] = nom;
                    tablaIdenFilas[1] = objSem.conversionNum(funcAmet.get(j));

                } else {
                    tablaIdenFilas[2] = funcAmet.get(j);
                    tablaIdenParam.add(tablaIdenFilas);
                    tablaIdenFilas = new String[5];
                }
            }
        } else {
            //Una vez que la funcion a sido guardada toca agregar los parametros de dicho metodo
            for (int j = 1; j < met.size(); j++) {
                //Cada dos datos es un parametro ya que se compone de TipoDato nombre
                if (j % 2 != 0) {
                    tablaIdenFilas[0] = nom;
                    tablaIdenFilas[1] = objSem.conversionNum(met.get(j));

                } else {
                    tablaIdenFilas[2] = met.get(j);
                    tablaIdenParam.add(tablaIdenFilas);
                    tablaIdenFilas = new String[5];
                }
            }
        }
        rango = new String[3];
        rango[0] = nom;
        rango[1] = (i + 1) + "";
        int lla = 1;

        for (int j = i + 1; j < divisionRenglones.length; j++) {
            palabras = new StringTokenizer(divisionRenglones[j], " =;(),");
            texto = "";
            while (palabras.hasMoreElements()) {
                texto = texto + palabras.nextToken();
            }
            if (texto.contains("{")) {
                lla++;
            } else if (texto.contains("}")) {
                lla--;
            }
            if (lla == 0) {
                rango[2] = (j + 1) + "";
                rangosAsig.add(rango);
                i = j;
                break;
            }
        }
        return banderaErrores;
    }

    public boolean validarOperaciones(int j, StringTokenizer palabras, StringTokenizer palabrasAux,
            StringTokenizer palabrasOper, String palabra, boolean banderaVV, int i, boolean banderaErrores) {
        Lexico lex = new Lexico();
        /*Como tendremos una asignacion y nos quedamos en el formato de
        TipoDato Variable = asignacion..
        Nosotros estabamos en el token Variable, por lo que ahora tendremos que avanzar hacia asignacion
         */

        palabras = new StringTokenizer(divisionRenglones[i], ";=(),+-*/^&|><", true);
        StringTokenizer p = new StringTokenizer(divisionRenglones[i], ";=(),&|><", true);
        String variableAsig = palabras.nextToken().replaceAll("\\n", "");
        p.nextToken();
        variableAsig = variableAsig.replaceAll(" ", "");
        //Validemos que no se trate de una operacion relacional
        String expresion = "", aux = "";
        palabras.nextToken();
        p.nextToken();
        boolean bol = true, opLogicos = false;
        List<String[]> tipo = new ArrayList<>();
        String aux2;
        if (variableAsig.equals("MIENTRAS") || variableAsig.equals("STF")) {
            //Si es operador relacional
            int par = 1;
            opLogicos = true;
            String[] temp = new String[2];
            temp[0] = lex.Etiquetar("(").numero + "";
            temp[1] = "(";
            tipo.add(temp);
            String exFin = "(";
            do {
                //Empezaremos a buscar las expresiones utilizadas en su condicion
                aux = eliminarEspacios(palabras.nextToken().replaceAll("\\n", ""));
                exFin += aux;
//                System.out.println("a" + aux + "a");
                if (!aux.equals(" ") && !aux.equals(";") && !aux.equals("")
                        && !aux.equals("{") && !aux.equals("}")) {
                    expresion = aux;
                    switch (aux) {
                        case ">":
                        case "<":
                        case "=":
                        case "&":
                        case "|":
                            aux2 = palabras.nextToken().replaceAll("\\n", "");
                            //Validamos si la operacion relacional es compuesta o simple 2>=3
                            if (aux2.equals("<") || aux2.equals(">") || aux2.equals("=")
                                    || aux2.equals("&") || aux2.equals("|")) {
                                expresion += aux2;
                            } else {
                                temp = new String[2];
                                temp[0] = lex.Etiquetar(expresion).numero + "";
                                if (temp[0].equals("52")) {
                                    variableUtil(expresion, i);
                                }
                                temp[1] = expresion;
                                tipo.add(temp);
                                expresion = aux2;
                            }
                            exFin += aux2;
                            break;
                        case "(":
                            par++;
                            break;
                        case ")":
                            par--;
                            break;
                    }
//                    System.out.println("Condicion: " + expresion);
                    temp = new String[2];
                    temp[0] = lex.Etiquetar(expresion).numero + "";
                    if (temp[0].equals("52")) {
                        variableUtil(expresion, i);
//                        System.out.println("Variable Utilizada en operacion logica, linea "+i);
                    }
                    temp[1] = expresion;
                    tipo.add(temp);

                }
            } while (palabras.hasMoreElements() && par != 0);

            tipo = obtenTipo(tipo, i);
            //Fase de pruebas
            boolean b = true;
            int cont = 0;
            for (int k = 0; k < tipo.size(); k++) {
                if (!tipo.get(k)[1].equals("||") && !tipo.get(k)[1].equals("&&")) {
                    if (!tipo.get(k)[1].equals("(") && !tipo.get(k)[1].equals(")") && !tipo.get(k)[1].equals(";")) {
                        if (!objSem.operLogCompatibles(tipo.get(k)[0], tipo.get(k + 1)[1], tipo.get(k + 2)[0])) {
                            System.out.println(tipo.get(k)[1] + tipo.get(k + 1)[1] + tipo.get(k + 2)[1]);
                            b = false;
                            break;
                        }
                        k += 2;
                    } else if (tipo.get(k)[1].equals("(")) {

                    } else {

                    }
                }
            }
            //Continuar problemas desde aqui FASE DE PRUEBAS- TERMINADO 80%

            if (b) {
                boolean asign;
                Pila<String> pila;
//                System.out.println("Expresion condicional " + exFin);
                pila = objSem.convertInfijPosOpLog(transformar(exFin, i));
                String prefija = pila.prefija();
                opInfija += "********************************Expresion********************************\n";
                opInfija += "Infija: \n" + "    " + variableAsig + " = " + exFin + "   --> Linea: " + (i + 1) + "\n"
                        + "Prefija: \n" + "    " + variableAsig + " = " + prefija + "   --> Linea: " + (i + 1) + "\n";

                if (!objSem.getValorFila().equals("")) {
                    opInfija += "\n~Operador~\t~Variable1~\t~Variable2~\t~VariableTemporal~\n";
                }

                opInfija += objSem.getValorFila() + "\n";
                objSem.setValorFila("");

                String valorL = objSem.evaluarLogicos(pila);
                opInfija += "Resultado final = " + valorL + "\n\n";

                jTProgramaCodigoIntermedio.setText(opInfija);
                asign = modifiarValor(variableAsig, valorL + "", i);
                variableUtil(variableAsig, i);
//                pila = transformar(exFin, i);
//                do {
//                    System.out.println("Pos: " + pila.pop());
//                } while (!pila.estaVacia());
                //String op = objSem.evaluarLogicos(pila) + "";
                /*if ((op.equals("VER") || op.equals("FALS"))) {
                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Operacion relacional correcta en linea " + (i + 1) + "\n");
                } else {
                    lbSem.setText("Semantico: Incorrecto");
                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Operacion relacional incorrecta en linea " + (i + 1) + "\n");
                }*/
            } else {
                lbSem.setText("Semantico: Incorrecto");
                banderaErrores = false;
                jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Operacion relacional incorrecta en linea " + (i + 1) + "\n");
            }
        } else {
            //Si es asignacion
            opLogicos = false;
            do {
                //Empezaremos a buscar las expresiones utilizadas en su asignacion separadas por operadores
                int c = 1;
                aux = palabras.nextToken().replaceAll("\\n", "");
//                System.out.println("a" + aux + "a" + c); 
                if (!aux.equals(" ") && !aux.equals(";") && !aux.equals("")) {
                    expresion += aux;
//                    System.out.println("b" + aux + "b" + (c + 1));
                    if (!aux.equals("+") && !aux.equals("-")
                            && !aux.equals("*") && !aux.equals("/") && !aux.equals(" ")) {
                        aux = aux.replaceAll(" ", "");
                        String[] temp = new String[2];
                        temp[0] = lex.Etiquetar(aux).numero + "";
                        if (temp[0].equals("52")) {
                            variableUtil(aux, i);
//                        System.out.println("Variable Utilizada en operacion aritmetica, linea "+i);
                        }
                        temp[1] = aux;
                        tipo.add(temp);
                        switch (temp[0]) {
                            case "51":
                            case "53":
                            case "54":
                                bol = false;
                                break;
                            case "17":
                            case "18":
                                opLogicos = true;
                                break;
                        }
//                        System.out.println("c" + aux + "c" + (c + 2));
                    }
                }
            } while (palabras.hasMoreElements());
            /*Hemos guardado los tipos de dato correspondientes a las expresiones halladas pero hasta ahora
            las variables tienen como tipo de dato asignado 52 por lo que queda buscarlas y obtener su tipo de dato
             */
            tipo = obtenTipo(tipo, i);

            /*Una vez halladas se valida que cada uno sea compatible con el tipo de dato definido a la primera variable
            Si se termina el recorrido con true significa que todos los datos son del mismo tipo y esta listo para realizar
            su operacion.
             */
            boolean b = true;
            for (int k = 0; k < tipo.size(); k++) {
                if (!objSem.operCompatibles(tablaIdenCol.get(j)[1], tipo.get(k)[0])) {
                    b = false;
                }
            }
            //FUNCIONAL
            if (b) {
                boolean asign;
                Pila<String> pila;
                //System.out.println("Linea " + i + " Infijo:" + variableAsig + "=" + expresion);
                if (bol && !opLogicos) {
                    //Si es operacion aritmetica
                    pila = objSem.convertInfijPos(transformar(expresion, i));
                    String prefija = pila.prefija();
                    double p2 = 0;
                    boolean aaa = true;
                    try {
                        p2 = objSem.evaluar(pila);
                    } catch (Exception ex) {
                        System.out.println("La operacion contiene variables sin declarar/inicializar");
                        aaa = false;
                        lbSem.setText("Semantico: Incorrecto");
                        banderaErrores = false;
                        jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "La operacion contiene variables sin declarar/inicializar en la linea: " + (i + 1) + "\n");

                    }
                    if (aaa) {
                        asign = modifiarValor(variableAsig, p2 + "", i);
                        variableUtil(variableAsig, i);
                        opInfija += "********************************Expresion********************************\n";
                        opInfija += "Infija: \n" + "    " + variableAsig + " = " + expresion + "   --> Linea: " + (i + 1) + "\n"
                                + "Prefija: \n" + "    " + variableAsig + " = " + prefija + "   --> Linea: " + (i + 1) + "\n";

                        if (!objSem.getValorFila().equals("")) {
                            opInfija += "\n~Operador~\t~Variable1~\t~Variable2~\t~VariableTemporal~\n";
                        }

                        opInfija += objSem.getValorFila() + "\n";
                        objSem.setValorFila("");

                        opInfija += "Resultado final === " + objSem.getResultadoFinal() + "\n\n";

                        jTProgramaCodigoIntermedio.setText(opInfija);
                        //objSem.addFila(i);
                    }

                } else if (!bol && !opLogicos) {
                    //Si es concatenacion
                    pila = objSem.convertInfijPosCad(transformar(expresion, i));
                    asign = modifiarValor(variableAsig, objSem.evaluarCadenas(pila) + "", i);
                    variableUtil(variableAsig, i);
                } else {
                    //Si es operacion logica/booleana
                    pila = objSem.convertInfijPosBooleans(transformar(expresion, i));
                    //asign = modifiarValor(variableAsig, objSem.evaluarLogicos(pila), i);

                    opInfija += "-----------Expresion-----------\n";
                    opInfija += "Infija: \n" + "    " + variableAsig + " = " + expresion + "   --> Linea: " + (i + 1) + "\n\n";
                    jTProgramaCodigoIntermedio.setText(opInfija);
                    variableUtil(variableAsig, i);
                }
                /*if (asign) {
                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Asignacion correcta en linea " + (i + 1) + "\n");
                } else {
                    lbSem.setText("Semantico: Incorrecto");
                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Asignacion incorrecta en linea " + (i + 1) + "\n");
                }*/
            } else {
                lbSem.setText("Semantico: Incorrecto");
                banderaErrores = false;
                jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Asignacion incorrecta en linea " + (i + 1) + "\n");
            }
        }
        return banderaErrores;
    }

    public boolean variableUtil(String variable, int i) {

        boolean dec = false;
        for (int l = 0; l < tablaIdenCol.size(); l++) {
            if (tablaIdenCol.get(l)[2].equals(variable)) {
                String[] temp1 = tablaIdenCol.get(l);
                temp1[4] = "VER";
                tablaIdenCol.add(l, temp1);
                tablaIdenCol.remove(l + 1);
                dec = true;
                //jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Valor: " + valor + " a variable: " + variable + ", modificado correctamente\n");
            }
        }
        //Validamos que no se haya encontrado como variable, por lo que revisaremos si esta en rango de parametro
        if (!dec) {
            int y = -1;
            for (int j = 0; j < rangosAsig.size(); j++) {
                if (rangosAsig.get(j)[0].equals(variable)) {
                    y = j;
                }
            }
            for (int l = 0; l < tablaIdenParam.size(); l++) {
                if (tablaIdenParam.get(l)[2].equals(variable) && y != -1
                        && (Integer.getInteger(rangosAsig.get(y)[1]) <= (i + 1) && Integer.getInteger(rangosAsig.get(y)[2]) >= (i + 1))) {
                    String[] temp1 = tablaIdenCol.get(l);
                    temp1[4] = "VER";
                    tablaIdenCol.add(l, temp1);
                    tablaIdenCol.remove(l + 1);
//                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Valor: " + valor + " a variable: " + variable + ", modificado correctamente\n");
                    dec = true;
                }
            }
        }

        return dec;
    }

    public String eliminarEspacios(String cadena) {
        StringBuilder resultado = new StringBuilder();
        boolean dentroComillas = false;
        for (int i = 0; i < cadena.length(); i++) {
            char c = cadena.charAt(i);
            if (c == '"') {
                dentroComillas = !dentroComillas;
            }
            if (c != ' ' || dentroComillas) {
                resultado.append(c);
            }
        }
        return resultado.toString();
    }

    public Pila<String> transformar(String expresion, int i) {
        StringTokenizer trans = new StringTokenizer(eliminarEspacios(expresion), ";=()+-*/^&|><", true);
        Pila<String> pila = new Pila<>();
        Pattern stringPattern = Pattern.compile("\"[\\w\\s]+\"");
        boolean dec = false;
        String aux;
        do {
            aux = trans.nextToken();
            if (aux.equals("VER") || aux.equals("FALS")) {
                dec = true;
            } else if (esNumero(aux)) {
                dec = true;
            } else if (stringPattern.matcher(aux).matches()) {
                dec = true;
            } else if (aux.equals("(") || aux.equals(")")) {
                dec = true;
            } else if (aux.equals("=")
                    || aux.equals(">")
                    || aux.equals("<")
                    || aux.equals("&")
                    || aux.equals("|")) {
                String aux2 = trans.nextToken();
                switch (aux2) {
                    case "=":
                    case ">":
                    case "<":
                    case "&":
                    case "|":
                        aux += aux2;
                        break;
                    default:
                        String a = aux2;
                        while (trans.hasMoreElements()) {
                            a += trans.nextToken();
                        }
                        trans = new StringTokenizer(eliminarEspacios(a), ";=()+-*/^&|><", true);
                }
                dec = true;
            } else {
                for (int l = 0; l < tablaIdenCol.size(); l++) {
                    if (tablaIdenCol.get(l)[2].equals(aux)) {
                        if (!tablaIdenCol.get(l)[3].equals("Null")) {
                            aux = tablaIdenCol.get(l)[3];
                            dec = true;
                        } else {
                            System.out.println("Error");
                            //Error
                            break;
                        }
                    }
                }
                //Validamos que no se haya encontrado como variable, por lo que revisaremos si esta en rango de parametro
                if (!dec) {
                    int y = -1;
                    for (int j = 0; j < rangosAsig.size(); j++) {
                        if (rangosAsig.get(j)[0].equals(aux)) {
                            y = j;
                        }
                    }

                    for (int l = 0; l < tablaIdenParam.size(); l++) {
                        if (tablaIdenParam.get(l)[0].equals(aux) && y != -1
                                && (Integer.getInteger(rangosAsig.get(y)[1]) <= (i + 1) && Integer.getInteger(rangosAsig.get(y)[2]) >= (i + 1))) {
                            aux = tablaIdenCol.get(l)[3];
                            dec = true;
                        }
                    }
                }
            }
            if (dec) {
                pila.push(aux);
            } else {
                //Error
                jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Error, variable sin asignacion. " + aux + " linea " + i + "\n");
                break;
            }

        } while (trans.hasMoreElements());

        return pila;
    }

    public boolean esNumero(String variable) {
        char[] arrChar = variable.toCharArray();
        boolean band = true;
        for (int i = 0; i < arrChar.length; i++) {
            if (!Character.isDigit(arrChar[i])) {
                band = false;
            }
        }
        return band;
    }

    public boolean modifiarValor(String variable, String valor, int i) {
//        for (int j = 0; j < tablaIdenCol.size(); j++) {
//            System.out.println("Variables: "+ tablaIdenCol.get(j)[2]+" valor: "+tablaIdenCol.get(j)[3]);
//        }

        boolean dec = false;
        for (int l = 0; l < tablaIdenCol.size(); l++) {
            if (tablaIdenCol.get(l)[2].equals(variable)) {
                String[] temp1 = tablaIdenCol.get(l);
                temp1[3] = valor;
                tablaIdenCol.add(l, temp1);
                tablaIdenCol.remove(l + 1);
                dec = true;
                //jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Valor: " + valor + " a variable: " + variable + ", modificado correctamente\n");
            }
        }
        //Validamos que no se haya encontrado como variable, por lo que revisaremos si esta en rango de parametro
        if (!dec) {
            int y = -1;
            for (int j = 0; j < rangosAsig.size(); j++) {
                if (rangosAsig.get(j)[0].equals(variable)) {
                    y = j;
                }
            }
            for (int l = 0; l < tablaIdenParam.size(); l++) {
                if (tablaIdenParam.get(l)[2].equals(variable) && y != -1
                        && (Integer.getInteger(rangosAsig.get(y)[1]) <= (i + 1) && Integer.getInteger(rangosAsig.get(y)[2]) >= (i + 1))) {
                    String[] temp1 = tablaIdenCol.get(l);
                    temp1[3] = valor;
                    tablaIdenCol.add(l, temp1);
                    tablaIdenCol.remove(l + 1);
                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Valor: " + valor + " a variable: " + variable + ", modificado correctamente\n");
                    dec = true;
                }
            }
        }
//        for (int j = 0; j < tablaIdenCol.size(); j++) {
//            System.out.println("Variables: "+ tablaIdenCol.get(j)[2]+" valor modificado: "+tablaIdenCol.get(j)[3]);
//        }

        System.out.println("Variable = " + variable + " Usada = " + dec);

        eliminaVarCAP(variable); // Elimina las variables que si se usan de los CAP

        return dec;
    }

    public List<String[]> obtenTipo(List<String[]> tipo, int i) {
        for (int k = 0; k < tipo.size(); k++) {
            if (tipo.get(k)[0].equals("52")) {
                boolean dec = false;
                for (int l = 0; l < tablaIdenCol.size(); l++) {
                    if (tablaIdenCol.get(l)[2].equals(tipo.get(k)[1])) {
                        String[] temp1 = new String[2];
                        temp1[0] = tablaIdenCol.get(l)[1];
                        temp1[1] = tipo.get(k)[1];
                        tipo.add(k, temp1);
                        tipo.remove(k + 1);
                        dec = true;
                    }
                }
                //Validamos que no se haya encontrado como variable, por lo que revisaremos si esta en rango de parametro
                if (!dec) {
                    int y = -1;
                    for (int j = 0; j < rangosAsig.size(); j++) {
                        if (rangosAsig.get(j)[0].equals(tipo.get(k)[1])) {
                            y = j;
                        }
                    }
                    for (int l = 0; l < tablaIdenParam.size(); l++) {
                        if (tablaIdenParam.get(l)[2].equals(tipo.get(k)[1]) && y != -1
                                && (Integer.getInteger(rangosAsig.get(y)[1]) <= (i + 1) && Integer.getInteger(rangosAsig.get(y)[2]) >= (i + 1))) {
                            String[] temp1 = new String[2];
                            temp1[0] = tablaIdenCol.get(l)[1];
                            temp1[1] = tipo.get(k)[1];
                            tipo.add(k, temp1);
                            tipo.remove(k + 1);
                            dec = true;
                        }
                    }
                }
                if (!dec) {
                    //Error de variable no declarada
                    lbSem.setText("Semantico: Incorrecto");
                    jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Variable no declarada en linea " + (i + 1) + "\n");
                }

            }
        }
        return tipo;
    }

    public boolean usada(String variable, int i) {

        boolean dec = false;
        for (int l = 0; l < tablaIdenCol.size(); l++) {
            if (tablaIdenCol.get(l)[2].equals(variable)) {
                String[] temp1 = tablaIdenCol.get(l);
                dec = true;
                return temp1[4].equals("VER");

                //jTProgramaSemantico.setText(jTProgramaSemantico.getText() + "Valor: " + valor + " a variable: " + variable + ", modificado correctamente\n");
            }
        }
        //Validamos que no se haya encontrado como variable, por lo que revisaremos si esta en rango de parametro
        if (!dec) {
            int y = -1;
            for (int j = 0; j < rangosAsig.size(); j++) {
                if (rangosAsig.get(j)[0].equals(variable)) {
                    y = j;
                }
            }
            for (int l = 0; l < tablaIdenParam.size(); l++) {
                if (tablaIdenParam.get(l)[2].equals(variable) && y != -1
                        && (Integer.getInteger(rangosAsig.get(y)[1]) <= (i + 1) && Integer.getInteger(rangosAsig.get(y)[2]) >= (i + 1))) {
                    String[] temp1 = tablaIdenCol.get(l);
                    System.out.println("La variable " + variable + " ha sido usada");
                    return temp1[4].equals("VER");
                }
            }
        }
        return false;
    }

    public int eliminaMetFunSU() {

//        for (int l = 0; l < tablaIdenCol.size(); l++) {
//            System.out.println(tablaIdenCol.get(l)[0] + " " + tablaIdenCol.get(l)[2] + " " + tablaIdenCol.get(l)[4]);
//        }
//
//        for (int l = 0; l < tablaIdenParam.size(); l++) {
//            System.out.println(tablaIdenParam.get(l)[0] + " " + tablaIdenParam.get(l)[2] + " " + tablaIdenParam.get(l)[4]);
//        }
        //Dividimos nuestro programa de acuerdo a los renglones
        divisionRenglones = programaEjecutado.split("(?<=\\n)");
        StringTokenizer palabras;
        String palabra = "";
        List<int[]> rangos = new ArrayList<>();
        //Iniciamos un recorrido para ver el rango de variables utilizadas en funciones
        for (int i = divisionRenglones.length - 1; i > 0; i--) {
            palabras = new StringTokenizer(divisionRenglones[i], " =;(),");
            palabra = palabras.nextToken().replaceAll("\n", "");
            //Cada que hallemos una declaracion de funcion/metodo verificaremos que haya sido o no usada
            if (palabra.equals("FUN") || palabra.equals("MET")) {
                String nom;
                switch (palabra) {
                    case "FUN":
                        palabras.nextToken();
                        nom = palabras.nextToken();
                        break;
                    default:
                        nom = palabras.nextToken().replaceAll("\"", "");
                }
                if (!usada(nom, i)) {
                    int[] x = new int[2];
                    for (int j = 0; j < rangosAsig.size(); j++) {
                        if (rangosAsig.get(j)[0].equals(nom)) {
                            x[0] = Integer.parseInt(rangosAsig.get(j)[1]);
                            x[1] = Integer.parseInt(rangosAsig.get(j)[2]);
                            break;
                        }
                    }
                    rangos.add(x);
                }
            }
        }
        //Iniciamos el recorrido de los renglones
        for (int i = divisionRenglones.length - 1; i > 0; i--) {
            //Separamos las palabras en un arreglo, de un renglon determinado por el ciclo 
            palabras = new StringTokenizer(divisionRenglones[i], " =;(),");

            palabra = palabras.nextToken().replaceAll("\n", "");
            if (palabra.equals("NUM") || palabra.equals("CAD")
                    || palabra.equals("CHAR") || palabra.equals("BOOL")) {
                //Encuentra declaracion de dato, almacenamos a que tipo se refiere
                String nom = palabras.nextToken();
                if (!usada(nom, i)) {
                    int[] x = new int[2];
                    for (int j = 0; j < tablaIdenCol.size(); j++) {
                        if (tablaIdenCol.get(j)[2].equals(nom)) {
                            x[0] = Integer.parseInt(tablaIdenCol.get(j)[0]);
                            x[1] = Integer.parseInt(tablaIdenCol.get(j)[0]);
                            break;
                        }
                    }
                    rangos.add(x);
                }
            }
        }
        for (int i = 0; i < rangos.size(); i++) {
            System.out.println("d " + i + "\ni" + rangos.get(i)[0] + " y" + rangos.get(i)[1] + "\n");
        }
        int res = 0;
        for (int i = 0; i < rangos.size(); i++) {
            for (int j = rangos.get(i)[0]; j <= rangos.get(i)[1]; j++) {
                divisionRenglones[j - 1] = "";
                res++;
            }
        }
        programaEjecutado = "";
        for (int i = 0; i < divisionRenglones.length; i++) {
            if (!divisionRenglones[i].equals("") && !divisionRenglones[i].equals("\n")) {
                programaEjecutado += divisionRenglones[i];
            }
        }
        return res;
    }
    private void lbIntermedioMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_lbIntermedioMouseClicked
        pnOptimizacion.setVisible(true);
        // TODO add your handling code here:
    }//GEN-LAST:event_lbIntermedioMouseClicked

    private void lbOptimizacionMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_lbOptimizacionMouseClicked
        pnObjeto.setVisible(true);
        int res = eliminaMetFunSU();
        int response = JOptionPane.showConfirmDialog(null, "¬°Recuerda!\nPulsa \"Guardar\"\nSi deseas conservar codigo optimizado.",
                "Lineas restantes" + res, JOptionPane.OK_OPTION);
        if (response == JOptionPane.OK_OPTION) {
//            jTProgramaFuente.setText(programaEjecutado);
            CodigoOp ven = new CodigoOp(programaEjecutado);
            ven.setVisible(true);
            try {
                ManejoArchivos.guardarArchivo(programaEjecutado, true);
                // TODO add your handling code here:

            } catch (IOException ex) {
                Logger.getLogger(InterfazPrincipal.class
                        .getName()).log(Level.SEVERE, null, ex);
            }
            JOptionPane.showMessageDialog(null, "Archivo optimizado Guardado con exito.");
        }

        // TODO add your handling code here:
    }//GEN-LAST:event_lbOptimizacionMouseClicked

    private void lbCargarMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_lbCargarMouseClicked
        pnSintactico.setVisible(false);
        pnSemantico.setVisible(false);
        pnIntermedio.setVisible(false);
        pnOptimizacion.setVisible(false);
        pnObjeto.setVisible(false);
        lbLex.setText("Lexico:");
        lbSin.setText("Sintactico:");
        lbSem.setText("Semantico:");
        jTProgramaCompilado.setText("");
        jTProgramaSintactico.setText("");
        jTProgramaSemantico.setText("");
        jTProgramaCodigoIntermedio.setText("");
        erroresLexicos.setText("");
        // TODO add your handling code here:
        jTProgramaFuente.setText(ManejoArchivos.cargarArchivo());
    }//GEN-LAST:event_lbCargarMouseClicked

    private void lbGuardarMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_lbGuardarMouseClicked
        try {
            ManejoArchivos.guardarArchivo(jTProgramaFuente.getText(), false);
            // TODO add your handling code here:

        } catch (IOException ex) {
            Logger.getLogger(InterfazPrincipal.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
        JOptionPane.showMessageDialog(null, "Archivo Guardado con exito.");
    }//GEN-LAST:event_lbGuardarMouseClicked

    private void jTProgramaFuenteKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTProgramaFuenteKeyTyped
        lbLexico.setText("Lexico:");
        lbSintactico.setText("Sintactico:");
        lbSemantico.setText("Semantico:");
    }//GEN-LAST:event_jTProgramaFuenteKeyTyped

    private void cambiaC(int l) {
        jTProgramaFuente.getLineCount();
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(InterfazPrincipal.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(InterfazPrincipal.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(InterfazPrincipal.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(InterfazPrincipal.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new InterfazPrincipal().setVisible(true);
            }
        });
    }

    /**
     * Este metodo busca las variables que son usadas en un CAP
     *
     * @param texto texto del codigo ejemplo
     * @return variables que contienen CAP
     */
    public static ArrayList<String> recopilarVarCap(String texto) {
        ArrayList<String> resultados = new ArrayList<>(); // Inicializa el ArrayList de resultados vac√≠o

        int startIndex = 0;
        while (startIndex != -1) {
            startIndex = texto.indexOf("CAP(", startIndex); // Busca la posici√≥n del inicio de la subcadena "CAP("
            if (startIndex != -1) { // Si se encuentra la subcadena "CAP("
                startIndex += 4; // Suma 4 para saltar el "CAP("
                int endIndex = texto.indexOf(")", startIndex); // Busca la posici√≥n del primer par√©ntesis de cierre ")" despu√©s de la subcadena "CAP("
                if (endIndex != -1) { // Si se encuentra el par√©ntesis de cierre ")"
                    String resultado = texto.substring(startIndex, endIndex); // Extrae la subcadena dentro del par√©ntesis
                    resultados.add(resultado); // Agrega la subcadena extra√≠da al ArrayList de resultados
                }
            }
        }

        HashSet<String> resultadosUnicos = new HashSet<>(resultados); // Crea un HashSet a partir del ArrayList para eliminar duplicados
        resultados.clear(); // Limpia el ArrayList original
        resultados.addAll(resultadosUnicos); // Agrega los resultados √∫nicos al ArrayList original

        return resultados;
    }

    /**
     * Metodo que elimina las variables que si son usadas en el codigo fuente
     *
     * @param palabraAEliminar
     */
    public void eliminaVarCAP(String palabraAEliminar) {
        for (int i = 0; i < variablesCAP.size(); i++) {
            if (variablesCAP.get(i).equals(palabraAEliminar)) {
                variablesCAP.remove(i);
                i--;
            }
        }
    }

    /**
     * Metodo que usa una lista con todas las variables no usadas para eliminar
     * CAP con dichas variables
     *
     * @param texto codigo fuente para realizar la eliminaci√≥n de CAP
     * @param varNoUsadas variables no usadas en el codigo fuente
     * @return texto nuevo con CAP eliminadas
     */
    public static String eliminaCAP(String texto, ArrayList<String> varNoUsadas) {
        String textoNuevo = "";

        for (int i = 0; i < varNoUsadas.size(); i++) {
            textoNuevo = texto.replaceAll("CAP\\(" + varNoUsadas.get(i) + "\\);\\s*", "");
        }

        return textoNuevo;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextArea erroresLexicos;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JTextArea jTProgramaCodigoIntermedio;
    private javax.swing.JTextArea jTProgramaCompilado;
    private javax.swing.JTextArea jTProgramaFuente;
    private javax.swing.JTextArea jTProgramaSemantico;
    private javax.swing.JTextArea jTProgramaSintactico;
    private javax.swing.JLabel lbCargar;
    private javax.swing.JLabel lbGuardar;
    private javax.swing.JLabel lbIntermedio;
    private javax.swing.JLabel lbLex;
    private javax.swing.JLabel lbLexico;
    private javax.swing.JLabel lbObjeto;
    private javax.swing.JLabel lbOptimizacion;
    private javax.swing.JLabel lbSem;
    private javax.swing.JLabel lbSemantico;
    private javax.swing.JLabel lbSin;
    private javax.swing.JLabel lbSintactico;
    private javax.swing.JPanel pnCarga1;
    private javax.swing.JPanel pnContenedor;
    private javax.swing.JPanel pnGuardar;
    private javax.swing.JPanel pnIntermedio;
    private javax.swing.JPanel pnLexico;
    private javax.swing.JPanel pnObjeto;
    private javax.swing.JPanel pnOptimizacion;
    private javax.swing.JPanel pnSemantico;
    private javax.swing.JPanel pnSintactico;
    // End of variables declaration//GEN-END:variables
}
